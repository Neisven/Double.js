"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _KeyValue_instances, _KeyValue_initializeTable, _KeyValue_getTableData, _KeyValue_setTableData, _KeyValue_hasTable;
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyValue = void 0;
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const node_events_1 = require("node:events");
const Error_1 = require("./Error");
function keys(obj) {
    if (typeof obj === "object")
        return Object.keys(obj);
    else
        return [];
}
function valuess(obj) {
    if (typeof obj === "object")
        return Object.values(obj);
    else
        return [];
}
function at(arr, index) {
    return index >= 1 ? arr[index] : arr[arr.length + index];
}
/**
 * Represents a key-value store with event handling capabilities.
 * @extends EventEmitter
 * @template K - Type of keys
 * @template V - Type of values
 */
class KeyValue extends node_events_1.EventEmitter {
    /**
     * Constructs a new KeyValue instance.
     * @param {Object} options - Configuration options for KeyValue.
     * @param {string} options.path - Path where the database is stored.
     * @param {string[]} options.tables - Array of table names in the database.
     * @param {string} options.extname - File extension for table storage files.
     */
    constructor(options = {}) {
        var _a, _b, _c;
        super();
        _KeyValue_instances.add(this);
        this.path = (_a = options.path) !== null && _a !== void 0 ? _a : "database";
        this.tables = (_b = options.tables) !== null && _b !== void 0 ? _b : ["main"];
        this.extname = (_c = options.extname) !== null && _c !== void 0 ? _c : ".sql";
        const existsPath = node_path_1.default.join(process.cwd(), this.path);
        if (!node_fs_1.default.existsSync(existsPath)) {
            node_fs_1.default.mkdirSync(existsPath);
        }
        let tableFile = this.tables;
        if (!Array.isArray(tableFile)) {
            throw new Error_1.CustomError("Invalid table array", "ErrorTable");
        }
        if (!this.extname) {
            throw new Error_1.CustomError("Invalid extension", "ErrorExtension");
        }
        for (const table of this.tables)
            __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_initializeTable).call(this, table);
    }
    /**
     * Adds an event listener for the specified event.
     * @param {string} event - Event name
     * @param {Function} listener - Event listener function
     * @returns {this} The current KeyValue instance
     * @override
     */
    on(event, listener) {
        super.on(event, listener);
        return this;
    }
    /**
     * Sets a key-value pair in a specified table.
     * @param {string} table - Name of the table
     * @param {K} key - Key to set
     * @param {V} value - Value to set
     * @returns {this} The current KeyValue instance
     * @emits {update} When a key-value pair is updated
     */
    set(table, key, value) {
        __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_hasTable).call(this, table);
        const getValue = this.get(table, key);
        let db = __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_getTableData).call(this, table, this.path, this.extname);
        db[key] = new Object({
            key,
            value,
        });
        const newValue = {
            tables: table,
            path: this.path,
            extname: this.extname,
            key,
            value,
        };
        const oldValue = {
            tables: table,
            path: this.path,
            extname: this.extname,
            key,
            value: getValue,
        };
        if (!this.has(table, key)) {
            this.emit("create", newValue);
        }
        if (this.has(table, key)) {
            this.emit("update", newValue, oldValue);
        }
        __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_setTableData).call(this, table, this.path, db, this.extname);
        return this;
    }
    /**
     * Retrieves the value associated with a key in a specified table.
     * @param {string} table - Name of the table
     * @param {K} key - Key to retrieve
     * @returns {V | undefined} The value associated with the key, or undefined if not found
     */
    get(table, key) {
        __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_hasTable).call(this, table);
        let db = __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_getTableData).call(this, table, this.path, this.extname);
        if (this.has(table, key)) {
            let values = db[key]["value"];
            return values;
        }
        else {
            return undefined;
        }
    }
    /**
     * Retrieves all key-value pairs in a specified table.
     * @param {string} table - Name of the table
     * @returns {Object} All key-value pairs in the table
     */
    all(table) {
        __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_hasTable).call(this, table);
        let db = __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_getTableData).call(this, table, this.path, this.extname);
        return db;
    }
    /**
     * Clears all key-value pairs in a specified table.
     * @param {string} table - Name of the table
     * @returns {this} The current KeyValue instance
     * @emits {deleteAll} When all key-value pairs in the table are deleted
     */
    delete(table, key, oldValues = false) {
        __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_hasTable).call(this, table);
        let db = __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_getTableData).call(this, table, this.path, this.extname);
        let values = this.get(table, key);
        const oldValue = {
            tables: table,
            path: this.path,
            extname: this.extname,
            key: key,
            value: values,
        };
        delete db[key];
        __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_setTableData).call(this, table, this.path, db, this.extname);
        this.emit("delete", oldValue);
        if (oldValues) {
            return values;
        }
    }
    /**
     * Clears all key-value pairs in a specified table.
     * @param {string} table - Name of the table
     * @returns {this} The current KeyValue instance
     * @emits {deleteAll} When all key-value pairs in the table are deleted
     */
    clear(table) {
        __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_hasTable).call(this, table);
        let db = {};
        const oldValue = {
            tables: table,
            path: this.path,
            extname: this.extname,
            value: this.all(table),
        };
        __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_setTableData).call(this, table, this.path, db, this.extname);
        this.emit("deleteAll", oldValue);
        return this;
    }
    /**
     * Checks if a key exists in a specified table.
     * @param {string} table - Name of the table
     * @param {K} key - Key to check
     * @returns {boolean} True if the key exists, false otherwise
     */
    has(table, key) {
        __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_hasTable).call(this, table);
        let db = __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_getTableData).call(this, table, this.path, this.extname);
        return db[key] === undefined ? false : true;
    }
    /**
     * Iterates over all key-value pairs in a specified table and executes a callback function.
     * @param {string} table - Name of the table
     * @param {Function} callback - Callback function to execute for each key-value pair
     */
    forEach(table, callback) {
        __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_hasTable).call(this, table);
        const db = __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_getTableData).call(this, table, this.path, this.extname);
        for (const key in db) {
            const value = db[key].value;
            callback(value, key, db);
        }
    }
    /**
     * Retrieves a specific key-value pair from a specified table.
     * @param {string} table - Name of the table
     * @param {K} key - Key to retrieve
     * @returns {Object | undefined} The key-value pair, or undefined if not found
     */
    filter(table, filterFn) {
        __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_hasTable).call(this, table);
        const db = __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_getTableData).call(this, table, this.path, this.extname);
        const filteredEntries = [];
        for (const key in db) {
            const value = db[key].value;
            if (filterFn(value, key, db)) {
                filteredEntries.push([key, value]);
            }
        }
        return filteredEntries;
    }
    /**
     * Retrieves a specific key-value pair from a specified table.
     * @param {string} table - Name of the table
     * @param {K} key - Key to retrieve
     * @returns {Object | undefined} The key-value pair, or undefined if not found
     */
    at(table, key) {
        var _a, _b, _c;
        __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_hasTable).call(this, table);
        const db = __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_getTableData).call(this, table, this.path, this.extname);
        if (((_a = db[key]) === null || _a === void 0 ? void 0 : _a.value) !== undefined) {
            return (_b = db[key]) === null || _b === void 0 ? void 0 : _b.value;
        }
        else if (typeof key === "number") {
            let res = [];
            for (const key in db) {
                const value = (_c = db[key]) === null || _c === void 0 ? void 0 : _c.value;
                res.push({ key, value });
            }
            return at(res, key);
        }
    }
    /**
     * Retrieves a random key-value pair from a specified table.
     * @param {string} table - Name of the table
     * @returns {V | undefined} A random value, or undefined if the table is empty
     */
    randomAt(table) {
        var _a;
        __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_hasTable).call(this, table);
        const db = __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_getTableData).call(this, table, this.path, this.extname);
        const keys = Object.keys(db);
        if (keys.length === 0)
            return undefined;
        const randomKey = keys[Math.floor(Math.random() * keys.length)];
        return (_a = db[randomKey]) === null || _a === void 0 ? void 0 : _a.value;
    }
    /**
     * Retrieves all keys from a specified table.
     * @param {string} table - Name of the table
     * @returns {Array<K>} Array of keys in the table
     */
    keys(table) {
        __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_hasTable).call(this, table);
        const db = __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_getTableData).call(this, table, this.path, this.extname);
        let res = [];
        for (const key in db) {
            res.push(key);
        }
        return res;
    }
    /**
     * Retrieves all values from a specified table.
     * @param {string} table - Name of the table
     * @returns {Array<V>} Array of values in the table
     */
    values(table) {
        __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_hasTable).call(this, table);
        const db = __classPrivateFieldGet(this, _KeyValue_instances, "m", _KeyValue_getTableData).call(this, table, this.path, this.extname);
        let res = [];
        for (const key in db) {
            res.push(db[key].value);
        }
        return res;
    }
    /**
     * Retrieves the length of key-value pairs in a specified table.
     * @param {string} table - Name of the table.
     * @returns {{ key: number, value: number }} - Object containing key and value counts.
     */
    length(table) {
        const key = this.keys(table);
        const value = this.values(table);
        return { key: key.length, value: value.length };
    }
    /**
     * Checks if a table exists.
     * @param {string} tableName - Name of the table to check.
     * @returns {boolean} - True if the table exists, otherwise false.
     */
    hasTable(tableName) {
        return this.tables.includes(tableName);
    }
    /**
     * Checks if a given string is a valid table name.
     * @param {string} table - Name of the table to check.
     * @returns {boolean} - True if it's a valid table, otherwise false.
     */
    isTable(table) {
        return this.tables.find((a) => a === table) === undefined ? false : true;
    }
    /**
     * Establishes a connection and emits a 'ready' event.
     * @emits ready - Emitted when the KeyValue instance is ready.
     */
    connect() {
        this.emit("ready", this);
    }
}
exports.KeyValue = KeyValue;
_KeyValue_instances = new WeakSet(), _KeyValue_initializeTable = function _KeyValue_initializeTable(table) {
    const tablePath = node_path_1.default.join(process.cwd(), this.path, table);
    const filePath = node_path_1.default.join(tablePath, `storage${this.extname}`);
    if (!node_fs_1.default.existsSync(tablePath)) {
        node_fs_1.default.mkdirSync(tablePath);
    }
    if (!node_fs_1.default.existsSync(filePath)) {
        const fileDescriptor = node_fs_1.default.openSync(filePath, "w");
        node_fs_1.default.writeFileSync(fileDescriptor, "{}");
        node_fs_1.default.closeSync(fileDescriptor);
    }
}, _KeyValue_getTableData = function _KeyValue_getTableData(tableName, directory, fileExtension) {
    const filePath = node_path_1.default.join(process.cwd(), directory, tableName, `storage${fileExtension}`);
    let fileDescriptor;
    try {
        fileDescriptor = node_fs_1.default.openSync(filePath, "r");
        const data = node_fs_1.default.readFileSync(filePath, "utf8");
        return JSON.parse(data);
    }
    catch (error) {
        console.error("Error reading file:", error);
        return {};
    }
    finally {
        if (fileDescriptor) {
            node_fs_1.default.closeSync(fileDescriptor);
        }
    }
}, _KeyValue_setTableData = function _KeyValue_setTableData(tableName, directory, data, fileExtension) {
    const content = JSON.stringify(data);
    const filePath = node_path_1.default.join(process.cwd(), directory, tableName, `storage${fileExtension}`);
    let fileDescriptor;
    try {
        fileDescriptor = node_fs_1.default.openSync(filePath, "w");
        node_fs_1.default.writeFileSync(fileDescriptor, content);
    }
    catch (error) {
        console.error("Error writing file:", error);
    }
    finally {
        if (fileDescriptor) {
            node_fs_1.default.closeSync(fileDescriptor);
        }
    }
}, _KeyValue_hasTable = function _KeyValue_hasTable(table) {
    if (!this.hasTable(table)) {
        throw new Error_1.CustomError(`Invalid table name: ${table}`, "ErrorTable");
    }
};
